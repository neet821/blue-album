# 🔒 路由保护完整测试指南

**更新时间:** 2025年10月19日  
**测试目标:** 验证所有受保护路由正确拦截未授权访问

---

## 📋 受保护的路由列表

| 路由 | 功能 | 说明 |
|------|------|------|
| `/tools` | 工具页面 | 🆕 新增保护 |
| `/tools/links` | 链接管理 | ✅ 已保护 |
| `/profile` | 个人资料 | 🆕 新增保护 |
| `/posts/new` | 发表文章 | ✅ 已保护 |
| `/posts/:id/edit` | 编辑文章 | ✅ 已保护 |
| `/admin/users` | 用户管理 | ✅ 已保护(需管理员) |

---

## 🧪 测试场景

### 场景 1: 无 Token 访问 (路由守卫拦截)

**目的:** 验证路由守卫在用户未登录时正确拦截

**测试步骤:**
1. 打开浏览器开发者工具 (F12)
2. 切换到 **Console** 标签
3. 执行命令删除 token:
   ```javascript
   localStorage.removeItem('token')
   ```
4. 访问任一受保护页面:
   - http://localhost:5173/tools
   - http://localhost:5173/tools/links
   - http://localhost:5173/profile
   - http://localhost:5173/posts/new

**预期结果:**
- ✅ **立即跳转** 到登录页 (URL 变为 `/login?message=请先登录`)
- ✅ 登录页显示红色错误提示: **"请先登录"**
- ✅ Console 显示路由守卫日志:
  ```
  🛡️ 路由守卫检查: { to: "/tools", requiresAuth: true, hasToken: false }
  ⚠️ 需要认证但没有 token,跳转到登录页
  ```

---

### 场景 2: 假 Token 访问 (API 拦截器拦截)

**目的:** 验证即使绕过路由守卫,API 请求也会被拦截

**测试步骤:**
1. 打开浏览器开发者工具 (F12)
2. 切换到 **Console** 标签
3. 执行命令设置假 token:
   ```javascript
   localStorage.setItem('token', 'fake-token-test-12345')
   ```
4. 访问受保护页面:
   ```
   http://localhost:5173/tools
   ```
5. **预期:** 能够进入页面 (因为路由守卫检测到 token 存在)
6. **关键步骤:** 尝试触发任意 API 请求:
   - 在工具页面点击 "链接管理工具"
   - 或尝试发表文章
   - 或访问个人资料

**预期结果:**
- ✅ 页面初始可以访问 (路由守卫通过)
- ✅ 触发 API 请求时,后端返回 **401 Unauthorized**
- ✅ axios 拦截器捕获 401 错误
- ✅ Console 显示详细日志:
  ```
  ========== 拦截器捕获错误 ==========
  错误对象: AxiosError
  响应状态: 401
  🔒 检测到 401 错误,开始处理...
  📊 当前 token: fake-token-test-12345
  ✅ Token 已清除
  🔄 准备跳转到登录页
  ```
- ✅ 自动清除假 token (执行 `localStorage.getItem('token')` 返回 `null`)
- ✅ 自动跳转到登录页 (URL 变为 `/login?message=登录已过期,请重新登录`)
- ✅ 登录页显示红色错误提示: **"登录已过期,请重新登录"**

---

### 场景 3: 正常登录后访问 (应该通过)

**目的:** 验证正常用户不受影响

**测试步骤:**
1. 访问 http://localhost:5173/login
2. 使用正确的用户名密码登录
3. 访问任一受保护页面

**预期结果:**
- ✅ 所有受保护页面正常访问
- ✅ API 请求自动携带正确的 token
- ✅ 功能正常使用

---

## 🎯 快速测试命令

### 删除 Token
```javascript
localStorage.removeItem('token')
```

### 设置假 Token
```javascript
localStorage.setItem('token', 'fake-token-test-12345')
```

### 检查当前 Token
```javascript
console.log('当前 token:', localStorage.getItem('token'))
```

### 查看 Token 内容 (解码)
```javascript
const token = localStorage.getItem('token')
if (token) {
  const payload = JSON.parse(atob(token.split('.')[1]))
  console.log('Token payload:', payload)
  console.log('过期时间:', new Date(payload.exp * 1000))
} else {
  console.log('没有 token')
}
```

---

## 🐛 常见问题排查

### 问题 1: 删除 token 后没有跳转

**可能原因:**
- 缓存问题
- 路由守卫未生效

**解决方法:**
1. 硬刷新页面: `Ctrl + Shift + R` (Windows) 或 `Cmd + Shift + R` (Mac)
2. 检查 Console 是否有错误
3. 确认 token 确实已删除: `localStorage.getItem('token')` 返回 `null`

### 问题 2: 假 token 可以正常使用

**可能原因:**
- 没有触发 API 请求
- 拦截器配置错误

**排查步骤:**
1. 确认确实点击了功能按钮 (触发 API)
2. 打开 **Network** 标签,筛选 **Fetch/XHR**
3. 查看是否有 API 请求
4. 查看请求的响应状态码是否为 401

### 问题 3: 没有看到错误提示

**可能原因:**
- 页面已经有其他错误
- 消息被覆盖

**解决方法:**
1. 刷新登录页
2. 检查 URL 是否包含 `?message=...`
3. 查看登录页顶部是否有红色错误框

---

## ✅ 测试检查表

完成所有测试后,确认以下项目:

- [ ] **场景 1 测试完成**
  - [ ] 删除 token 后访问 `/tools` 被拦截
  - [ ] 删除 token 后访问 `/profile` 被拦截
  - [ ] 删除 token 后访问 `/posts/new` 被拦截
  - [ ] 所有情况都显示 "请先登录" 消息

- [ ] **场景 2 测试完成**
  - [ ] 假 token 可以进入页面
  - [ ] 触发 API 后被拦截
  - [ ] Console 显示详细日志
  - [ ] 自动清除假 token
  - [ ] 显示 "登录已过期" 消息

- [ ] **场景 3 测试完成**
  - [ ] 正常登录后可以访问所有页面
  - [ ] 功能正常使用

---

## 📊 技术实现说明

### 双层防护机制

#### 第一层: 路由守卫 (router/index.js)
```javascript
router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('token');
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);

  if (requiresAuth && !token) {
    // 没有 token,拦截访问
    next({
      path: '/login',
      query: { message: '请先登录' }
    });
  } else {
    next();
  }
});
```

**优点:** 
- 快速响应,无需等待 API 请求
- 防止未登录用户看到页面内容

**局限:**
- 只检查 token **是否存在**
- 不验证 token **是否有效**
- 无法防止使用假 token

#### 第二层: Axios 拦截器 (utils/request.js)
```javascript
// 响应拦截器
request.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      // 后端验证失败,token 无效
      const authStore = useAuthStore();
      authStore.logout();
      router.push({ 
        path: '/login', 
        query: { message: '登录已过期,请重新登录' } 
      });
    }
    return Promise.reject(error);
  }
);
```

**优点:**
- 后端真正验证 token 有效性
- 捕获所有 401 错误
- 自动清理无效 token

**配合使用:**
两层防护互补,确保**无论用户如何尝试**,都无法绕过认证访问受保护资源。

---

**测试愉快! 🎉**
